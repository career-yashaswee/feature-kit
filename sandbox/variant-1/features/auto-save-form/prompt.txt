You are given a task to integrate a React component into your codebase.
Please verify your project has the following setup:
- Next.js project (App Router)
- shadcn/ui project structure (or compatible UI library)
- Tailwind CSS
- TypeScript
- `@uidotdev/usehooks` package installed
- `framer-motion` package installed
- `sonner` package installed
- `lucide-react` package installed
- `react-hook-form` package installed (for form handling)

If any of these are missing, provide instructions on how to install them:
- Install dependencies: `npm install @uidotdev/usehooks framer-motion sonner lucide-react react-hook-form`
- If shadcn/ui is not set up, guide the user to install it via: `npx shadcn@latest init`
- If Button, Input, or Label components don't exist, install them via: `npx shadcn@latest add button input label`

Determine the default path for components and utilities.
- Components should go in /components folder
- If /lib/utils.ts doesn't exist, create it with the cn utility function

Check if /lib/utils.ts exists. If not, create it:

File location: lib/utils.ts

File content: import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


Copy-paste this component to /components folder:

File location: components/auto-save-form.tsx

File content: "use client";

import { type ReactNode, useEffect, useRef, useState } from "react";
import { useDebounce } from "@uidotdev/usehooks";
import { motion, AnimatePresence } from "framer-motion";
import { Check, Loader2, AlertCircle } from "lucide-react";
import { toast } from "sonner";

interface AutoSaveFormProps<T extends Record<string, unknown>> {
  children: ReactNode;
  onSave: (data: T, signal?: AbortSignal) => Promise<void> | void;
  data: T;
  debounceMs?: number;
  storageKey?: string;
  onSaveStart?: () => void;
  onSaveSuccess?: () => void;
  onSaveError?: (error: Error) => void;
  onLoadFromStorage?: (data: T) => void;
  showIndicator?: boolean;
  indicatorPosition?: "top-right" | "top-left" | "bottom-right" | "bottom-left";
  successMessage?: string;
  errorMessage?: string;
}

type SaveStatus = "idle" | "saving" | "saved" | "error";

function getIndicatorClasses(
  position: AutoSaveFormProps<never>["indicatorPosition"],
): string {
  const base =
    "absolute z-10 flex items-center gap-1.5 rounded-md bg-background/95 backdrop-blur-sm border px-2 py-1 text-xs font-medium shadow-sm";

  switch (position) {
    case "top-left":
      return `${base} top-2 left-2`;
    case "bottom-left":
      return `${base} bottom-2 left-2`;
    case "bottom-right":
      return `${base} bottom-2 right-2`;
    case "top-right":
    default:
      return `${base} top-2 right-2`;
  }
}

export function AutoSaveForm<T extends Record<string, unknown>>({
  children,
  onSave,
  data,
  debounceMs = 1000,
  storageKey,
  onSaveStart,
  onSaveSuccess,
  onSaveError,
  onLoadFromStorage,
  showIndicator = true,
  indicatorPosition = "top-right",
  successMessage = "Changes saved",
  errorMessage = "Failed to save changes",
}: AutoSaveFormProps<T>) {
  const [status, setStatus] = useState<SaveStatus>("idle");
  const debouncedData = useDebounce(data, debounceMs);
  const previousDataRef = useRef<T | null>(null);
  const isInitialMount = useRef(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const statusTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
      if (debouncedData != null) {
        previousDataRef.current = debouncedData;
      }

      if (storageKey && typeof window !== "undefined") {
        try {
          const saved = localStorage.getItem(storageKey);
          if (saved) {
            const parsed = JSON.parse(saved) as Partial<T>;
            const merged = { ...data, ...parsed };
            onLoadFromStorage?.(merged);
          }
        } catch {
          // Ignore localStorage errors
        }
      }
      return;
    }

    if (previousDataRef.current == null || debouncedData == null) {
      if (debouncedData != null) {
        previousDataRef.current = debouncedData;
      }
      return;
    }

    const hasChanged =
      JSON.stringify(previousDataRef.current) !== JSON.stringify(debouncedData);

    if (!hasChanged) return;

    previousDataRef.current = debouncedData;

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();

    const saveData = async () => {
      setStatus("saving");
      onSaveStart?.();

      if (storageKey && typeof window !== "undefined") {
        try {
          localStorage.setItem(storageKey, JSON.stringify(debouncedData));
        } catch {
          // Ignore localStorage errors
        }
      }

      try {
        await Promise.resolve(
          onSave(debouncedData, abortControllerRef.current?.signal),
        );

        if (abortControllerRef.current?.signal.aborted) return;

        setStatus("saved");
        onSaveSuccess?.();
        toast.success(successMessage);

        if (statusTimeoutRef.current) {
          clearTimeout(statusTimeoutRef.current);
        }
        statusTimeoutRef.current = setTimeout(() => {
          setStatus((prev) => (prev === "saved" ? "idle" : prev));
        }, 2000);
      } catch (error) {
        if (abortControllerRef.current?.signal.aborted) return;

        setStatus("error");
        const err = error instanceof Error ? error : new Error(errorMessage);
        onSaveError?.(err);
        toast.error(errorMessage);

        if (statusTimeoutRef.current) {
          clearTimeout(statusTimeoutRef.current);
        }
        statusTimeoutRef.current = setTimeout(() => {
          setStatus((prev) => (prev === "error" ? "idle" : prev));
        }, 3000);
      }
    };

    saveData();

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      if (statusTimeoutRef.current) {
        clearTimeout(statusTimeoutRef.current);
        statusTimeoutRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    debouncedData,
    onSave,
    storageKey,
    onSaveStart,
    onSaveSuccess,
    onSaveError,
    successMessage,
    errorMessage,
  ]);

  return (
    <div className="relative">
      <AnimatePresence>
        {showIndicator && status !== "idle" && (
          <motion.div
            initial={{ opacity: 0, y: -10, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -10, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className={getIndicatorClasses(indicatorPosition)}
          >
            {status === "saving" && (
              <>
                <Loader2 className="h-3 w-3 animate-spin text-muted-foreground" />
                <span className="text-muted-foreground">Saving...</span>
              </>
            )}
            {status === "saved" && (
              <>
                <Check className="h-3 w-3 text-green-600 dark:text-green-400" />
                <span className="text-green-600 dark:text-green-400">
                  Saved
                </span>
              </>
            )}
            {status === "error" && (
              <>
                <AlertCircle className="h-3 w-3 text-destructive" />
                <span className="text-destructive">Error</span>
              </>
            )}
          </motion.div>
        )}
      </AnimatePresence>
      {children}
    </div>
  );
}


Now, integrate this component into your form:

File location: app/page.tsx (or any page with a form)

Instructions:
1. Import AutoSaveForm from "@/components/auto-save-form"
2. Import useForm from "react-hook-form" (or your form library)
3. Import Toaster from "sonner" and add it to your layout
4. Wrap your form with AutoSaveForm component
5. Pass form data via the data prop
6. Provide an onSave function that accepts the data and optional AbortSignal

Example integration:

```tsx
"use client";

import { useForm } from "react-hook-form";
import { AutoSaveForm } from "@/components/auto-save-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

interface FormData extends Record<string, unknown> {
  title: string;
  description: string;
}

async function saveFormData(data: FormData, signal?: AbortSignal) {
  await fetch("/api/save", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data),
    signal,
  });
}

export default function MyPage() {
  const { register, watch, reset } = useForm<FormData>({
    defaultValues: { title: "", description: "" },
  });

  const formData = watch();

  return (
    <AutoSaveForm
      data={formData}
      onSave={saveFormData}
      storageKey="my-form"
      debounceMs={1000}
      onLoadFromStorage={(loadedData) => {
        reset(loadedData);
      }}
    >
      <form className="space-y-4">
        <div>
          <Label htmlFor="title">Title</Label>
          <Input id="title" {...register("title")} />
        </div>
        <div>
          <Label htmlFor="description">Description</Label>
          <Input id="description" {...register("description")} />
        </div>
      </form>
    </AutoSaveForm>
  );
}
```

Also add Toaster to your layout:

File location: app/layout.tsx

```tsx
import { Toaster } from "sonner";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        {children}
        <Toaster richColors position="top-right" />
      </body>
    </html>
  );
}
```

Customization examples:

Basic usage:
```tsx
<AutoSaveForm data={formData} onSave={saveFormData}>
  <form>{/* Your form fields */}</form>
</AutoSaveForm>
```

With localStorage backup:
```tsx
<AutoSaveForm
  data={formData}
  onSave={saveFormData}
  storageKey="my-form-data"
  onLoadFromStorage={(data) => reset(data)}
>
  <form>{/* Your form fields */}</form>
</AutoSaveForm>
```

Custom debounce and messages:
```tsx
<AutoSaveForm
  data={formData}
  onSave={saveFormData}
  debounceMs={2000}
  successMessage="Your changes have been saved!"
  errorMessage="Oops! Something went wrong."
>
  <form>{/* Your form fields */}</form>
</AutoSaveForm>
```

With callbacks:
```tsx
<AutoSaveForm
  data={formData}
  onSave={saveFormData}
  onSaveStart={() => console.log("Saving...")}
  onSaveSuccess={() => console.log("Saved!")}
  onSaveError={(error) => console.error("Error:", error)}
>
  <form>{/* Your form fields */}</form>
</AutoSaveForm>
```

Important notes:
- The component automatically debounces form data changes
- Status indicator shows "Saving...", "Saved", or "Error" states
- localStorage backup is optional but recommended for data persistence
- AbortSignal is provided to cancel in-flight requests
- The component handles cleanup automatically
- Form data type must extend Record<string, unknown>

Testing:
1. Type in form fields
2. Wait for debounce period (default: 1 second)
3. Status indicator should appear showing "Saving..."
4. After save completes, indicator shows "Saved" or "Error"
5. Check localStorage for backup data (if storageKey provided)

